// 尾调用
// 尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，
// 我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，
// 所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。
// 但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

// 简单的尾调用实现
function f(x){
    return g(x);
  }
  // 或者这样的
  function f(x) {
    if (x > 0) {
      return m(x)
    }
    return n(x);
  }
//错误示范以下不属于尾调用
  // 情况一
  function f(x){
    let y = g(x);
    return y;
  } 
  // 情况二
  function f(x){
    return g(x) + 1;
  } 
  // 情况三
  function f(x){
    g(x);
  }

// 尾调用通俗解释
// 在函数结束的时候，通过 return 调用函数。只能调用函数，不能在进行其他的处理，就像情况2一样还需要在进行处理的函数
// ！！！函数结束不一定就是函数的最后一行
// 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。
// 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
// 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了
// 总之：就是减少页面的调用帧 . 避免 调用栈 溢出。
